require('dotenv').config();

const express = require('express');
const bodyParser = require('body-parser');
const axios = require('axios');
const logger = require('./logger');
const fs = require('fs');
const FormData = require('form-data');

const app = express();
const PORT = process.env.PORT || 8898;

const sessionMap = new Map();
const timeoutMap = new Map();
const INACTIVITY_LIMIT = 10 * 60 * 1000;

const MessageType = Object.freeze({
  AUDIO: 'audioMessage',
  TEXT: 'conversation',
});

let token_api;

async function getToken() {
  const clientId = `${process.env.API_USERNAME}`;
  const password = `${process.env.API_PASSWORD}`;

  const res = await fetch(`${process.env.API_BASE_URL}/api/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ client_id: clientId, password }),
  });

  if (!res.ok) {
    const body = await res.text().catch(() => '');
    throw new Error(`Falha no login (${res.status} ${res.statusText}): ${body}`);
  }

  const data = await res.json().catch(() => ({}));
  const token = typeof data?.message === 'string' ? data.message : null;
  if (!token) throw new Error('Resposta nÃ£o contÃ©m "message" com o token.');

  return token; // <- exatamente no formato { token: "xxxx" }
}




app.use(bodyParser.json());

async function sendWhatsappMessage(number, instance, text) {
  logger.info(`ğŸ“¨ Enviando mensagem para ${number}: "${text}"`);
  try {
    const response = await axios.post(
      `${process.env.EVOLUTION_BASE_URL}/message/sendText/${instance}`,
      {
        number,
        text,
        mentionsEveryOne: true,
        mentioned: [number],
      },
      {
        headers: { apikey: process.env.EVOLUTION_APIKEY },
      }
    );
    logger.info(`âœ… Mensagem enviada com sucesso para ${number}`);
    return response.data;
  } catch (err) {
    logger.error(err, `âŒ Erro ao enviar mensagem: ${err.message}`);
  }
}

async function sendWhatsappAudioMessage(number, instance, text, keyspace, token) {
  //let token_api;
  try {
    token_api = await getToken();
    logger.info({ token_api });
  } catch (err) {
    logger.error(err);
  }
  const response = await axios({
    method: 'POST',
    url: `${process.env.API_BASE_URL}/api/speech/from-text`,
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${token_api}`,
    },
    data: {
      text,
      language: 'pt',
    },
    responseType: 'arraybuffer',
  });
  const base64Audio = Buffer.from(response.data, 'binary').toString('base64');

  logger.info(`ğŸ“¨ Enviando mensagem para ${number}: "${text}"`);
  try {
    const response = await axios.post(
      `${process.env.EVOLUTION_BASE_URL}/message/sendWhatsAppAudio/${instance}`,
      {
        number,
        'audio': base64Audio,
        mentionsEveryOne: true,
        mentioned: [number],
      },
      {
        headers: { apikey: process.env.EVOLUTION_APIKEY },
      }
    );
    logger.info(`âœ… Mensagem enviada com sucesso para ${number}`);
    return response.data;
  } catch (err) {
    logger.error(err, `âŒ Erro ao enviar mensagem: ${err.message}`);
  }
}

function resetInactivityTimer(number, instance, sessionid, token) {
  logger.info(`â±ï¸ Resetando timer de inatividade para ${number}`);
  if (timeoutMap.has(number)) {
    clearTimeout(timeoutMap.get(number));
    logger.info(`ğŸ” Timer anterior cancelado para ${number}`);
  }

  const timeout = setTimeout(async () => {
    logger.info(
      `âŒ› Inatividade detectada para ${number}, encerrando atendimento.`
    );
    const text =
      'Opa! JÃ¡ passamos 10 minutinhos aqui, entÃ£o vou encerrar o atendimento por agora. Se precisar de mais alguma coisa, Ã© sÃ³ chamar. AtÃ© mais!';
    await sendWhatsappMessage(number, instance, text);
    sessionMap.delete(number);
    timeoutMap.delete(number);
    logger.info(`ğŸ§¹ SessÃ£o e timer removidos para ${number}`);
  }, INACTIVITY_LIMIT);

  timeoutMap.set(number, timeout);
}

async function getEnvironmentSettings(instance) {
  const environmentName = instance.split('-').slice(1).join('-');
  const keyspaceName = instance.split('-')[0];

  logger.info(
    `ğŸ” Buscando settings para environment: ${environmentName} e keyspace: ${keyspaceName}`
  );



  let parsedSettings = {
        "whatsapp_webhook_token": process.env.EVOLUTION_APIKEY,
	"clientId": process.env.EVOLUTION_INSTANCE
   }

  logger.info(
    `âœ… Settings carregados para ${environmentName}:`,
    parsedSettings
  );

  return {
    token: parsedSettings.whatsapp_webhook_token,
    clientId: parsedSettings.eva_client_id,
    keyspace: keyspaceName,
  };
}

async function handleAudioMessage(messageBody, token, keyspace) {
  logger.info(`===== ğŸ™ï¸ AUDIO MESSAGE =====`, messageBody);
}

async function getAudioMessageData(instance, messageId) {
  const response = await axios({
    method: 'POST',
    url: `${process.env.EVOLUTION_BASE_URL}/chat/getBase64FromMediaMessage/${instance}`,
    data: {
      message: {
        key: {
          id: messageId,
        },
      },
      convertToMp4: true,
    },
    headers: {
      apikey: process.env.EVOLUTION_APIKEY,
      'Content-Type': 'application/json',
    },
  });
  return response.data?.base64;
}

async function getTextFromAudioFile(audioFilePath, token, keyspace) {
  try {
    const formData = new FormData();
    formData.append('audio', fs.createReadStream(audioFilePath));
    formData.append('language', 'pt_BR');

    //let token_api;
    try {
      token_api = await getToken();
      logger.info({ token_api });
    } catch (err) {
      logger.error(err);
    }

    const evaResponse = await axios({
      method: 'POST',
      url: `${process.env.API_BASE_URL}/api/speech/from-audio`,
      headers: {
        Authorization: `Bearer ${token_api}`,
        ...formData.getHeaders(),
      },
      data: formData,
    });
    logger.info(`Eva response: ${JSON.stringify(evaResponse.data, null, 2)}`);

    return evaResponse?.data?.text;
  } catch (error) {
    logger.error(error, `Error getting audio message:`, error.message);
    logger.error(error, `Error processing audio:`, error.message);
  } finally {
    if (audioFilePath && fs.existsSync(audioFilePath)) {
      fs.unlinkSync(audioFilePath);
      logger.info(`Cleaned up temporary file: ${audioFilePath}`);
    }
  }
}

app.use(async (req, res, next) => {
  try {
    logger.info(`===== ğŸ“¥ NOVA REQUISIÃ‡ÃƒO =====`);
    logger.info({
      headers: req.headers,
      body: req.body,
    });

    if (!req.body || req.body.event !== 'messages.upsert') {
      logger.warn(`âš ï¸ RequisiÃ§Ã£o ignorada: evento nÃ£o suportado.`);
      return next();
    }
    const instance = req.body.instance;
    const { token, clientId, keyspace } =
      await getEnvironmentSettings(instance);
    const number = req.body.data?.key?.remoteJid?.replace(/\D/g, '');
    let message = req.body.data?.message?.conversation;
    const isAudioMessage = req.body.data?.messageType == MessageType.AUDIO
    if (isAudioMessage) {
      const now = new Date();
      const timestamp = now.toISOString().replace(/[:.]/g, '-');
      let fileName = `${timestamp}.ogg`;
      const messageId = req.body.data?.key?.id;
      let mediaData = await getAudioMessageData(instance, messageId);
      const mediaDataBuffer = Buffer.from(mediaData, 'base64');
      fs.writeFileSync(fileName, mediaDataBuffer);
      message = await getTextFromAudioFile(fileName, token, keyspace);
    }

    if (!number || !message || !instance) {
      logger.warn(
        `âš ï¸ Dados incompletos: nÃºmero, mensagem ou instÃ¢ncia ausente.`
      );
      return next();
    }

    logger.info(`ğŸ“² Mensagem recebida de ${number}: "${message}"`);

    const isFirstMessage = !sessionMap.has(number);
    const sessionid = sessionMap.get(number) || '';

    let payload, template;

    if (isFirstMessage) {
      template = 'template_saudacao';
      payload = {
        memory: JSON.stringify({
          role: 'system',
          content:
            'VocÃª Ã© um representante comercial querendo vender um produto ou uma franquia.',
        }),
        query: message,
        searchdocs: false,
        temperature: 0.9,
        template,
	email: false,
	zendesk: false,
        client_id: clientId,
        sessionid: '',
        username: `WHATSAPP {{${number}}}`,
      };
      logger.info(`ğŸ‘‹ Primeira mensagem recebida. Template: ${template}`);
    } else {
      template = 'template_contexto';
      payload = {
        query: message,
        memory: '{}',
        searchdocs: true,
        temperature: '0.2',
        template,
        client_id: clientId,
        email: false,
        zendesk: false,
        sessionid,
        username: `WHATSAPP {{${number}}}`,
        cl: '1',
        engine: 'azure',
      };
      logger.info(`ğŸ’¬ Mensagem de sequÃªncia. Template: ${template}`);
    }

    const askUrl = `${process.env.API_BASE_URL}/api/ai/ask`;
    logger.info(`ğŸ“¡ Enviando para: ${askUrl}`);
    logger.info(`ğŸ“¦ Payload:`, JSON.stringify(payload));
    
    //let token_api;
    try {
      token_api = await getToken();
      logger.info({ token_api });
    } catch (err) {
      logger.error(err);
    }

    const askResponse = await axios.post(askUrl, payload, {
      headers: { Authorization: `Bearer ${token_api}` },
    });

    const botMessage = askResponse.data?.message || 'NÃ£o entendi sua pergunta.';
    logger.info(`ğŸ¤– Resposta do bot: "${botMessage}"`);

    if (isFirstMessage && askResponse.data?.sessionid) {
      sessionMap.set(number, askResponse.data.sessionid);
      logger.info(
        `ğŸ’¾ SessÃ£o criada: ${number} -> ${askResponse.data.sessionid}`
      );
    }
    if (isAudioMessage) {
      await sendWhatsappAudioMessage(number, instance, botMessage, keyspace, token);
    } else {
      await sendWhatsappMessage(number, instance, botMessage);
    }
    
    resetInactivityTimer(number, instance, sessionid, token);
  } catch (error) {
    logger.error(error, 'âŒ Erro no middleware de mensagens:', error.stack);
  }

  next();
});

app.all('*', (req, res) => {
  res.send('OK');
});

app.listen(PORT, () => {
  logger.info(`ğŸš€ Webhook rodando na porta ${PORT}`);
});
